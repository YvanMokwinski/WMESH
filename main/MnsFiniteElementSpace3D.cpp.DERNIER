
//#include "Err.h"
#include <valarray>
//#include "TimeMeasure.h"
//#include "Logging/Error.hpp"
//#include "Logging/Warning.hpp"

#include <iostream>
#include <ostream>
#include "Program.hpp"
#include <limits>
#include <array>

#include "DimensionType.hpp"
#include "ReferenceShape.hpp"

#include "ReferenceShapeNode.hpp"
#include "ReferenceShapeEdge.hpp"
#include "ReferenceShapeFaceTriangle.hpp"
#include "ReferenceShapeFaceQuadrilateral.hpp"
#include "ReferenceShapeVolumeTetrahedron.hpp"
#include "ReferenceShapeVolumePyramid.hpp"
#include "ReferenceShapeVolumeWedge.hpp"
#include "ReferenceShapeVolumeHexahedron.hpp"

#include "Config.hpp"
#include "Point.hpp"
#include "CellToNodes.hpp"

#include "Input/Medit.hpp"
#include "Mesh.hpp"
#include "Output/Medit.hpp"
#include "Output/Vtk.hpp"

#include "FiniteElement/Lagrange.hpp"

#include "EdgeCompare.hpp"
#include "FaceCompare.hpp"
#include "AHF/Mesh.hpp"


inline void HalfFaceDecomposition(const int_t halfFaceIndex_,
				  const int_t numDofsPerCell_,
				  const int_t numDofsPerInteriorFace_,
				  int_t* cellIndex_,
				  int_t* localFaceIndex_)
{
  cellIndex_[0] = halfFaceIndex_ / numDofsPerCell_;
  localFaceIndex_[0] = ( halfFaceIndex_ % numDofsPerCell_ ) / numDofsPerInteriorFace_;
#ifndef NDEBUG
  if (localFaceIndex_[0]<0 || localFaceIndex_[0] >=4)
    {
      std::cerr << "error"<< std::endl;
      exit(1);
    }
#endif
};

inline void HalfEdgeDecomposition(const int_t halfEdgeIndex_,
				  const int_t numDofsPerCell_,
				  const int_t numDofsPerInteriorEdge_,
				  int_t* cellIndex_,
				  int_t* localEdgeIndex_)
{
  cellIndex_[0] = halfEdgeIndex_ / numDofsPerCell_;
  localEdgeIndex_[0] = ( halfEdgeIndex_ % numDofsPerCell_ ) / numDofsPerInteriorEdge_;
#ifndef NDEBUG
  if (localEdgeIndex_[0]<0 || localEdgeIndex_[0] >=6)
    {
      std::cerr << "error"<< std::endl;
      exit(1);
    }
#endif
};

template <unsigned int _n> inline void GetCellToNodes(const int_t*__restrict__ cellsToNodes_,
						      const int_t cellsToNodesLd_,
						      const int_t cellIndex_,
						      int_t cnc_[])
{
  for (unsigned int localNodeIndex=0;localNodeIndex<_n;++localNodeIndex)
    {
      cnc_[localNodeIndex] = cellsToNodes_[cellIndex_*cellsToNodesLd_+localNodeIndex];
    }
}


template <VolumeType::enum_t _volumeType> inline void GetEdgeToNodes(const int_t 	cnc_[],
										  const int_t 	localEdgeIndex_,
										  int_t 		cncedge_[])		    
{
  cncedge_[0] = cnc_[ReferenceShapeVolume<_volumeType>::EdgesToNodes[localEdgeIndex_][0]];
  cncedge_[1] = cnc_[ReferenceShapeVolume<_volumeType>::EdgesToNodes[localEdgeIndex_][1]];
};



template <VolumeType::enum_t _volumeType,FaceType::enum_t _faceType>
struct Extract
{
public: static inline void GetFaceToNodes(const int_t 	cnc_[],
					  const int_t 	localFaceIndex_,
					  int_t 	cncface_[]);
};

template <VolumeType::enum_t _volumeType> struct Extract<_volumeType,FaceType::Triangle>
{

public: static inline void GetFaceToNodes(const int_t 	cnc_[],
					  const int_t 	localFaceIndex_,
					  int_t 	cncface_[])
  {
    cncface_[0] = cnc_[ReferenceShapeVolume<_volumeType>::TrianglesToNodes[localFaceIndex_][0]];
    cncface_[1] = cnc_[ReferenceShapeVolume<_volumeType>::TrianglesToNodes[localFaceIndex_][1]];
    cncface_[2] = cnc_[ReferenceShapeVolume<_volumeType>::TrianglesToNodes[localFaceIndex_][2]];
  };
};

template <VolumeType::enum_t _volumeType> struct Extract<_volumeType,FaceType::Quadrilateral>
{
public: static inline void GetFaceToNodes(const int_t 	cnc_[],
					  const int_t 	localFaceIndex_,
					  int_t 	cncface_[])
  {
    cncface_[0] = cnc_[ReferenceShapeVolume<_volumeType>::QuadrilateralsToNodes[localFaceIndex_][0]];
    cncface_[1] = cnc_[ReferenceShapeVolume<_volumeType>::QuadrilateralsToNodes[localFaceIndex_][1]];
    cncface_[2] = cnc_[ReferenceShapeVolume<_volumeType>::QuadrilateralsToNodes[localFaceIndex_][2]];
    cncface_[3] = cnc_[ReferenceShapeVolume<_volumeType>::QuadrilateralsToNodes[localFaceIndex_][3]];
  };
};

//
// Definition of a MeshHalfFacet
//
template <typename _derived> struct Traits_CRTP_MeshHalfFacet;

template <typename _derived> struct CRTP_MeshHalfFacet
{
private: inline const _derived & asImp() const { return static_cast<const _derived&>(*this); }    
private: inline _derived & asImp()  { return static_cast<_derived&>(*this); }    

private: using traits_t = Traits_CRTP_MeshHalfFacet<_derived>;
public: CRTP_MeshHalfFacet(const CRTP_MeshHalfFacet<_derived>&) = delete;  

protected: inline CRTP_MeshHalfFacet(){};
  
public: using cell_t = typename traits_t::cell_t;
  
public: inline cell_t		GetMeshCell() 		const noexcept
  {
    return asImp().GetMeshCell();
  };
  
public: inline unsigned int	GetLocalFacetIndex() 	const noexcept
  {
    return asImp().GetLocalFacetIndex();
  };  
};


namespace AHF
{
  template <DimensionType::enum_t _dimension>  struct MeshHalfFacet;
};

template <DimensionType::enum_t _dimension>  
struct CRTP_MeshHalfFacet< AHF::MeshHalfFacet<_dimension> >
{
  using cell_t = AHF::MeshEntity<_dimension>;
};

namespace AHF
{
  template <DimensionType::enum_t _dimension> struct MeshHalfFacet : public CRTP_MeshHalfFacet< MeshHalfFacet<_dimension> >
  {
  private: using this_t = MeshHalfFacet<_dimension>;
  private: using base_t = CRTP_MeshHalfFacet<this_t>;
    
  private: using cell_t = typename base_t::cell_t;    
  public: inline cell_t	GetCell() const noexcept
    {
      //
      // uncode the cellIndex + kind
      //
      return cell_t(0);
    };
    
  public: inline int_t 		GetLocalFacetIndex() 	const noexcept
    {
      return cell_t(0);
    };
    
  public: inline 		MeshHalfFacet(const cell_t 	cellIndex_,
					      const int_t 	localFaceIndex_)
    {
      //
      //
      // Encod cellIndex_ with the localFaceIndex_
      // the localFaceIndex_ 4,5,5,6 so 3 bits are needed
      //
      //      
    };
    
  private: int_t m_encoding; 
  };

};


class CellToCellsCalculator
{
#if 0  
  template <VolumeType::enum_t _volumeType,
	    FaceType::enum_t _faceType,
	    typename _int_t>  
  unsigned long long int GenerateHalfFacets(const int_t			numCells_,
					    const int_t*__restrict__ 	cellsToNodes_,
					    const int_t cellsToNodesLd_,
					    MeshHalfFace * 		cellsToCells_,
					    const int_t 		cellsToCellsOffset_,
					    Hasher<_int_t>&		hasher_)
  {    
    static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolume<_volumeType>::NbNodes;
    static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolume<_volumeType>::NbFaces;    
    static constexpr unsigned int s_numNodesInFace 	 = ReferenceShapeFace<_faceType>::NbNodes;    
    
    unsigned long long int numFaces = 0;    

    int_t facetToNodes[s_numNodesInFace];	  
    int_t cellToNodes[s_numVerticesInCell];

    for (int_t cellIndex=0;cellIndex<numCells_;++cellIndex)
      {	
	//
	// Copy connectivity.
	//
	GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					    cellsToNodesLd_,
					    cellIndex,
					    cellToNodes);
	
	_I at = s_numDofsPerCell * cellIndex;
	for (unsigned int localFaceIndex=0;localFaceIndex<s_numFacesInCell;++localFaceIndex)
	  {	      
	    //
	    // Extract the edgeToNodes.
	    //
	    Extract<_volumeType,_faceType>::GetFaceToNodes(cellToNodes,
							   localFaceIndex,
							   facetToNodes);
	    
	    //
	    // Compute has value.
	    //
	    const _I hashValue = FaceCompare<_faceType>::HashCode(numCells_,
								  facetToNodes);
	    
	    cellsToCells_[at] = hasher_[hashValue];
	    //
	    // Update the last half edge index with respect to the hash value.
	    //
	    hasher_[hashValue] = -at;
	    ++at;
	  }	
      }
    
    for (int_t cellIndex=numCells_-1;cellIndex>=0;--cellIndex)
      {	
	//
	// Extract the cell-to-nodes
	//
	GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					    cellsToNodesLd_,					    
					    cellIndex,
					    cellToNodes);
	
	for (int localFaceIndex = s_numFacesInCell-1;localFaceIndex>=0;--localFaceIndex)
	  {
	    int_t at 			= cellsToCellsOffset_ * cellIndex + localFaceIndex;
	    _I 	  nextHalfFaceIndex 	= cellsToCells_[at];
	    if (nextHalfFaceIndex < 0)
	      {		
		++numFaces;
		
		//
		// Extract the faces-to-nodes
		//
		Extract<_volumeType,FaceType::Triangle>::GetFaceToNodes(cellToNodes,
									localFaceIndex,
									faceToNodes);
		
		while (nextHalfFaceIndex < 0 && nextHalfFaceIndex != Hasher<_int_t>::s_default_hash)
		  {		    
		    int_t testedCellIndex;
		    int_t testedLocalFaceIndex;
		    
		    HalfFaceDecomposition(-nextHalfFaceIndex,
					  s_numDofsPerCell,
					  s_numDofsPerInteriorFace,
					  &testedCellIndex,
					  &testedLocalFaceIndex);
		    
		    //
		    // We need to extract the next half face before we overwrite it.
		    //
		    const _I nextHalfFaceIndexBackup = nextHalfFaceIndex;
		    nextHalfFaceIndex = cellsToDofs_[-nextHalfFaceIndex];
		    
		    int_t testedFaceToNodes[4];		    
		    {
		      int_t testedCellToNodes[s_numVerticesInCell];
		      GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
							  cellsToNodesLd_,					    
							  testedCellIndex,
							  testedCellToNodes);
		      
		      Extract<_volumeType,FaceType::Triangle>::GetFaceToNodes(testedCellToNodes,
									      testedLocalFaceIndex,
									      testedFaceToNodes);
		    }
		    
		    if (FaceCompare<_faceType>::AreSame(faceToNodes,
							testedFaceToNodes))
		      {
			//
			// We need to rebuild the linked list.
			//
			if (lastDifferentHalfFaceIndex != initialHalfFaceIndex)
			  {				
			    cellsToDofs_[-lastDifferentHalfFaceIndex] = nextHalfFaceIndex;
			  }			
			const _I at = s_numDofsPerCell*testedCellIndex+s_numVerticesInCell+ s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace*testedLocalFaceIndex;			
			cellsToCells_[at] = testedCellIndex;			
			cellsToCells_[testedCellIndex * s_numFacesInCell + testedLocalFaceIndex] = cellIndex; 
			break;			
		      }
		  }		
	      }
	  }
      }    
    std::cout << "numFaces " << numFaces << std::endl;   
    return numFaces;  
  };
  
  
  template <VolumeType::enum_t _volumeType,
	    typename int_t>
  void Calculate(const int_t 			numCells_,
		 const int_t*__restrict__ 	cellsToNodes_,
		 const int_t 			cellsToNodesLd_,
		 MeshHalfFace * 		cellsToCells_)
  {    
    static constexpr unsigned int s_numVerticesInCell = Cell::NbNodes;
    int_t* cellsToDofs = new int_t[numCells_ * s_numDofsPerCell];
    Hasher<int_t> hasher(numCells_);
    numFaces =  GenerateFace<_degree, _volumeType, FaceType::Triangle, int_t>(numCells_,
									      cellsToNodes_,
									      cellsToNodesLd_,
									      &dofIndex,
									      cellsToDofs,
									      hasher);
    numDofs_[0] = ++dofIndex;
    return cellsToDofs;  
  };
#endif  
};



namespace FiniteElement
{

  template <unsigned int _degree>
  struct Lagrange<_degree,
		  DimensionType::Node,
		  NodeType::Node>
  {
  public: static constexpr const unsigned int NumDofs = (_degree > 0) ? 1 : 0;
  public: static constexpr const std::array<unsigned int,1> NumDofsPerEntities
    {{ NumDofs }};    
  };

  template <unsigned int _degree> using LagrangeNode = Lagrange<_degree,
								DimensionType::Node,
								NodeType::Node>;
  
  
  
  template <unsigned int _degree>
  struct Lagrange<_degree,
		  DimensionType::Edge,
		  EdgeType::Edge>
  {
  public: static constexpr const unsigned int NumDofs = _degree+1;
  public: static constexpr const std::array<unsigned int,2> NumDofsPerEntities
    {{ LagrangeNode<_degree>::NumDofs,
	  (_degree>0) ? _degree-1 : 0 }};    
  };

  template <unsigned int _degree> using LagrangeEdge = Lagrange<_degree,
								DimensionType::Edge,
								EdgeType::Edge>;

  template <unsigned int _degree,FaceType::enum_t _faceType> using LagrangeFace = Lagrange<_degree,
												     DimensionType::Face,
												     _faceType>;
  
  template <unsigned int _degree>
  struct Lagrange<_degree,
		  DimensionType::Face,
		  FaceType::Triangle>
  {    
  public: static constexpr const unsigned int NumDofs = ((_degree+1)*(_degree+2)) / 2;
  public: static constexpr const std::array<unsigned int,3> NumDofsPerEntities
    {{ LagrangeNode<_degree>::NumDofs,
	  LagrangeEdge<_degree>::NumDofsPerEntities[DimensionType::Edge],
	  (_degree>2) ? ((_degree-1)*(_degree-2))/2 : 0}};
  };

  template <unsigned int _degree> using LagrangeFaceTriangle = LagrangeFace<_degree,
									    FaceType::Triangle>;
  
  template <unsigned int _degree>
  struct Lagrange<_degree,
		  DimensionType::Face,
		  FaceType::Quadrilateral>
  {    
  public: static constexpr const unsigned int NumDofs = (_degree+1)*(_degree+1);
  public: static constexpr const std::array<unsigned int,3> NumDofsPerEntities
    {{ LagrangeNode<_degree>::NumDofs,
	  LagrangeEdge<_degree>::NumDofsPerEntities[DimensionType::Edge],
	  (_degree-1)*(_degree-1)}};
  };
  
  template <unsigned int _degree> using LagrangeFaceQuadrilateral = LagrangeFace<_degree,
										 FaceType::Quadrilateral>;




  
  template <unsigned int _degree> struct Lagrange<_degree,
						  DimensionType::Volume,
						  VolumeType::Hexahedron>
  {

#if 0    
  private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeHexahedron::NbNodes;
  private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeHexahedron::NbEdges;
  private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeHexahedron::NbFaces;
    
  public: static constexpr unsigned int NumDofsPerCell 	 	= (_degree+1)*(_degree+1)*(_degree+1);
  public: static constexpr unsigned int NumDofsPerInteriorEdge 	= (_degree>0) ? _degree-1 : 0;
    
  public: static constexpr unsigned int NumDofsPerInteriorFace[2]
    { 0 , LagrangeFaceQuadrilateral<_degree>::NumDofsPerEntities[DimensionType::Face] };
    
  public: static constexpr unsigned int NumDofsPerInteriorVolume = NumDofsPerCell
		   - s_numVerticesInCell
		   - s_numEdgesInCell * NumDofsPerInteriorEdge
		   - 2 * NumDofsPerInteriorFace[0]
		   - 3 * NumDofsPerInteriorFace[1];
#endif

  private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeHexahedron::NbNodes;
  private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeHexahedron::NbEdges;
  private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeHexahedron::NbFaces;

  public: static constexpr unsigned int NumDofs 	 	= (_degree+1)*(_degree+1)*(_degree+1);
  public: static constexpr const unsigned int NumDofsPerInteriorNode[1]{ LagrangeNode<_degree>::NumDofsPerEntities[0]};
  public: static constexpr const unsigned int NumDofsPerInteriorEdge[1]{ LagrangeEdge<_degree>::NumDofsPerEntities[1]};
  public: static constexpr const unsigned int NumDofsPerInteriorFace[2]{ 0, LagrangeFaceQuadrilateral<_degree>::NumDofsPerEntities[2]};
    
  public: static constexpr const unsigned int NumDofsPerInteriorVolume[4]{NumDofs
	- s_numVerticesInCell
	- s_numEdgesInCell * LagrangeEdge<_degree>::NumDofsPerEntities[1]
	- s_numFacesInCell * LagrangeFaceQuadrilateral<_degree>::NumDofsPerEntities[2],0,0,0};
    
  public: static constexpr const unsigned int * NumDofsPerEntities[4]{
    NumDofsPerInteriorNode,
      NumDofsPerInteriorEdge,
      NumDofsPerInteriorFace,
      NumDofsPerInteriorVolume};
    
  };
  
  
  template <unsigned int _degree>
  struct Lagrange<_degree,DimensionType::Volume,VolumeType::Tetrahedron>
  {
#if 0    
  private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeTetrahedron::NbNodes;
  private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeTetrahedron::NbEdges;
  private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeTetrahedron::NbFaces;
  
  public: static constexpr unsigned int NumDofsPerCell 	 	= ((_degree+1)*(_degree+2)*(_degree+3)) / 6;
  public: static constexpr unsigned int NumDofsPerInteriorEdge 	= (_degree>0) ? _degree-1 : 0; 
  public: static constexpr unsigned int NumDofsPerInteriorFace[2]
    { LagrangeFaceTriangle<_degree>::NumDofsPerEntities[DimensionType::Face],
	0};
    
  public: static constexpr unsigned int
  NumDofsPerInteriorVolume = NumDofsPerCell
		   - s_numVerticesInCell
		   - s_numEdgesInCell * NumDofsPerInteriorEdge
		   - s_numFacesInCell * NumDofsPerInteriorFace[0];
#endif
    
  private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeTetrahedron::NbNodes;
  private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeTetrahedron::NbEdges;
  private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeTetrahedron::NbFaces;

  public: static constexpr unsigned int NumDofs 	 	= ((_degree+1)*(_degree+2)*(_degree+3)) / 6;  
  public: static constexpr const unsigned int NumDofsPerInteriorNode[1]{ LagrangeNode<_degree>::NumDofsPerEntities[0]};
  public: static constexpr const unsigned int NumDofsPerInteriorEdge[1]{ LagrangeEdge<_degree>::NumDofsPerEntities[1]};
  public: static constexpr const unsigned int NumDofsPerInteriorFace[2]{ LagrangeFaceTriangle<_degree>::NumDofsPerEntities[2],
	0};
    
  public: static constexpr const unsigned int NumDofsPerInteriorVolume[4]{NumDofs
	- s_numVerticesInCell
	- s_numEdgesInCell * LagrangeEdge<_degree>::NumDofsPerEntities[1]
	- s_numFacesInCell * LagrangeFaceTriangle<_degree>::NumDofsPerEntities[2],0,0,0};
  public: static constexpr const unsigned int * NumDofsPerEntities[4]{
    NumDofsPerInteriorNode,
      NumDofsPerInteriorEdge,
      NumDofsPerInteriorFace,
      NumDofsPerInteriorVolume};

  };

  
  template <unsigned int _degree> struct Lagrange<_degree,DimensionType::Volume,VolumeType::Wedge>
  {

  private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeWedge::NbNodes;
  private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeWedge::NbEdges;
  private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeWedge::NbFaces;
  
    //
    // 2 * n = (_degree+1)*(_degree+1)*(_degree+1) + (_degree+1)*(_degree+1)
    // n = ( (_degree+1)*(_degree+1)*(_degree+1) + (_degree+1)*(_degree+1) ) / 2
    //
  
  public: static constexpr unsigned int NumDofsPerCell 	 	= ((_degree+1)*(_degree+1)*(_degree+2)) / 2;
  public: static constexpr unsigned int NumDofsPerInteriorEdge 	= (_degree>0) ? _degree-1 : 0;
  
  public: static constexpr unsigned int NumDofsPerInteriorFace[]
    { LagrangeFaceTriangle<_degree>::NumDofsPerEntities[DimensionType::Face],
	LagrangeFaceQuadrilateral<_degree>::NumDofsPerEntities[DimensionType::Face] };
  
  public: static constexpr unsigned int NumDofsPerInteriorVolume = NumDofsPerCell
		   - s_numVerticesInCell
		   - s_numEdgesInCell * NumDofsPerInteriorEdge
		   - 2 * NumDofsPerInteriorFace[0]
		   - 3 * NumDofsPerInteriorFace[1];

  public: static constexpr const unsigned int NumDofs = ((_degree+1)*(_degree+1)*(_degree+2)) / 2;
    
  };
  
};


#if 0
template <unsigned int _degree> struct FiniteElement::Lagrange<_degree,DimensionType::Volume,VolumeType::Pyramid>
{
private: static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumePyramid::NbNodes;
private: static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumePyramid::NbEdges;
private: static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumePyramid::NbFaces;
  //
  // 6*n = (_degree+1)*(_degree+1)*(_degree+1) + ( 2 * (_degree-1) ) * 8
  //
  
public: static constexpr unsigned int NumDofsPerCell 	 	= ((_degree+1)*(_degree+1)*(_degree)) / 2;
public: static constexpr unsigned int NumDofsPerInteriorEdge 	= (_degree>0) ? _degree-1 : 0;
  
public: static constexpr unsigned int NumDofsPerInteriorFace[]
  { (_degree>2) ? ((_degree-1)*(_degree-2))/2 : 0,
      (_degree>0) ? (_degree-1)*(_degree-1) : 0 };
  
public: static constexpr unsigned int NumDofsPerInteriorVolume = NumDofsPerCell
    - s_numVerticesInCell
    - s_numEdgesInCell * NumDofsPerInteriorEdge
    - 4 * NumDofsPerInteriorFace[0]
    - 1 * NumDofsPerInteriorFace[1];
  
};
#endif




template <unsigned int _degree, typename _int_t>
void GenerateVolume(const _int_t numCells_,
		    const _int_t*__restrict__ cellsToNodes_,
		    const _int_t cellsToNodesLd_,
		    _int_t*numDofs_,
		    _int_t* __restrict__ cellsToDofs_,
		    const int cellsToDofsLD_)
{
  _int_t dofIndex = numDofs_[0];
  
  static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeTetrahedron::NbNodes;
  static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeTetrahedron::NbEdges;
  static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeTetrahedron::NbFaces;
  
  using fe_t = FiniteElement::Lagrange<_degree,DimensionType::Volume,VolumeType::Tetrahedron>;
#if 0
  static constexpr unsigned int s_numDofsPerCell 	 	= finiteElement_t::NumDofsPerCell;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= finiteElement_t::NumDofsPerInteriorEdge;
#endif

  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];
  static constexpr unsigned int s_numDofsPerInteriorFace 	= fe_t::NumDofsPerEntities[DimensionType::Face][FaceType::Triangle];
  static constexpr unsigned int s_numDofsPerInteriorVolume 	= fe_t::NumDofsPerEntities[DimensionType::Volume][VolumeType::Tetrahedron];
  
#if 0  
  //
  // Incorect
  //
  static constexpr unsigned int s_numDofsPerInteriorFace 	= finiteElement_t::NumDofsPerInteriorFace[0]+finiteElement_t::NumDofsPerInteriorFace[1];
  static constexpr unsigned int s_numDofsPerInteriorVolume 	= finiteElement_t::NumDofsPerInteriorVolume;
#endif  
  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorFace   " << s_numDofsPerInteriorFace   << std::endl;

  if (s_numDofsPerInteriorVolume>0)
    {
      //
      // Set dofs over the volumes.
      //
      for (_int_t cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  auto p = &cellsToDofs_[cellsToDofsLD_*cellIndex];
	  //	  const _int_t at = s_numDofsPerCell * cellIndex + s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace * s_numFacesInCell;
	  for (unsigned int k = 0;k<s_numDofsPerInteriorVolume;++k)
	    {
	      p[k] = ++dofIndex;
	      // cellsToDofs_[at + k] = ++dofIndex;
	    }
	}
    }
  
#ifndef NDEBUG
  std::cout << "volume table " << std::endl;    
  //
  // mark face
  //
  if (s_numDofsPerInteriorVolume>0)
    {
      for (_int_t cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  auto p = &cellsToDofs_[cellsToDofsLD_*cellIndex];
	  //	  const _int_t at = s_numDofsPerCell * cellIndex + s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace * s_numFacesInCell;
	  for (unsigned int k = 0;k<s_numDofsPerInteriorVolume;++k)
	    {
	      //
	      // only the first dof on edge.
	      //
	      //  std::cout << " " << cellsToDofs_[at +k];
	      std::cout << " " << p[k];
	    }
	  std::cout << std::endl;
	}
    }
#endif
  numDofs_[0] = dofIndex;
};

#include "Hasher.hpp"



#if 0
template <unsigned int _degree,VolumeType::enum_t _volumeType, FaceType::enum_t _faceType,typename _I>
void GenerateFaceHashBasedLinkedList(const _I numCells_,
				     const _I*__restrict__ cellsToNodes_,
				     const _I cellsToNodesLd_,
				     _I* __restrict__ cellsToDofs_,
				     const _I cellsToDofsLd_,
				     Hasher<_I>&hasher_)
{

  using Cell = ReferenceShapeVolume<_volumeType>;
  static constexpr unsigned int s_numVerticesInCell 	 = Cell::NbNodes;
  static constexpr unsigned int s_numEdgesInCell 	 = Cell::NbEdges;
  static constexpr unsigned int s_numFacesOfTypeInCell 	 = Cell::NbFacesOfType[_faceType];
  
  using finiteElement_t = FiniteElement::Lagrange<_degree,DimensionType::Volume,_volumeType>;
  
  static constexpr unsigned int s_numDofsPerCell 	 	= finiteElement_t::NumDofsPerCell;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= finiteElement_t::NumDofsPerInteriorEdge;
  
  _I faceToNodes[4];	  
  _I cellToNodes[s_numVerticesInCell];
  
  static constexpr const unsigned int s_localShift = s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge;
  for (_I cellIndex=0;cellIndex<numCells_;++cellIndex)
    {
      //
      // Copy connectivity.
      //
      GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					  cellsToNodesLd_,					  
					  cellIndex,
					  cellToNodes);
      
      _I at = cellsToDofsLd_ * cellIndex + s_localShift;
      for (unsigned int localFaceOfTypeIndex=0;localFaceOfTypeIndex<s_numFacesOfTypeInCell;++localFaceOfTypeIndex)
	{	      
	  //
	  // Extract the faceToNodes.
	  //
	  Extract<_volumeType,_faceType>::GetFaceToNodes(cellToNodes,
							 localFaceOfTypeIndex,
							 faceToNodes);
	  
	  //
	  // Compute has value.
	  //
	  const _I hashValue = FaceCompare<_faceType>::HashCode(numCells_,
								faceToNodes);
	  
	  //
	  // Assign the last half edge index with the same hash value.
	  //
	  //		cellsToDofs_[at] = link[hashValue];
	  cellsToDofs_[at] = hasher_[hashValue];
	  //
	  // Update the last half edge index with respect to the hash value.
	  //
	  hasher_[hashValue] = -at;
	  at += s_numDofsPerInteriorFace;
	}	
    }
  
};
#endif

template <unsigned int _degree,VolumeType::enum_t _volumeType, FaceType::enum_t _faceType, typename _I>
unsigned long long int GenerateFace(const _I numCells_,
				    const _I*__restrict__ cellsToNodes_,
				    const _I cellsToNodesLd_,
				    _I*numDofs_,
				    _I* __restrict__ cellsToDofs_,
				    const _I cellsToDofsLd_,
				    Hasher<_I>&hasher_)
{
  _I dofIndex = numDofs_[0];

  static constexpr unsigned int s_numVerticesInCell 	 = ReferenceShapeVolumeTetrahedron::NbNodes;
  static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeTetrahedron::NbEdges;
  static constexpr unsigned int s_numFacesInCell 	 = ReferenceShapeVolumeTetrahedron::NbFaces;
  
  using fe_t = FiniteElement::Lagrange<_degree,DimensionType::Volume,VolumeType::Tetrahedron>;

  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];
  static constexpr unsigned int s_numDofsPerInteriorFace 	= fe_t::NumDofsPerEntities[DimensionType::Face][FaceType::Triangle];
  
  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorFace   " << s_numDofsPerInteriorFace   << std::endl;

  unsigned long long int numFaces = 0;
  
  //
  // Set dofs over the faces.
  //
  if (s_numDofsPerInteriorFace > 0)
    {
      static constexpr const  _I s = (_degree-1)*(_degree-1);
      
      _I* permloc = new _I[s > s_numDofsPerInteriorFace ? s : s_numDofsPerInteriorFace];
      
      {      
	
	_I faceToNodes[4];	  
	_I cellToNodes[s_numVerticesInCell];
	
	static constexpr const unsigned int s_localShift = s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge;
	for (_I cellIndex=0;cellIndex<numCells_;++cellIndex)
	  {
	    //
	    // Copy connectivity.
	    //
	    GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
						cellsToNodesLd_,					    
						cellIndex,
						cellToNodes);
	    
	    _I at = s_numDofsPerCell * cellIndex + s_localShift;
	    for (unsigned int localFaceIndex=0;localFaceIndex<s_numFacesInCell;++localFaceIndex)
	      {	      
		//
		// Extract the face.
		//
		Extract<_volumeType,_faceType>::GetFaceToNodes(cellToNodes,
							       localFaceIndex,
							       faceToNodes);
		
		//
		// Compute hash value.
		//
		const _I hashValue = FaceCompare<_faceType>::HashCode(numCells_,
								      faceToNodes);
		
		//
		// Assign the last half edge index with the same hash value.
		//
		//		cellsToDofs_[at] = link[hashValue];
		cellsToDofs_[at] = hasher_[hashValue];
		//
		// Ujpdate the last half edge index with respect to the hash value.
		//
		hasher_[hashValue] = -at;
		at += s_numDofsPerInteriorFace;
	      }	
	  }
      }
      
      _I faceToNodes[4];	  
      _I cellToNodes[s_numVerticesInCell];
      _I interiorFaceDofIndices[s_numDofsPerInteriorFace];    
      for (_I cellIndex=numCells_-1;cellIndex>=0;--cellIndex)
	{	
	  
	  GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					      cellsToNodesLd_,					    
					      cellIndex,
					      cellToNodes);
	  
	  for (int localFaceIndex = s_numFacesInCell-1;localFaceIndex>=0;--localFaceIndex)
	    { 
	      const _I initialHalfFaceIndex = -(s_numDofsPerCell*cellIndex+ s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace*localFaceIndex + 0);
	      _I nextHalfFaceIndex = cellsToDofs_[-initialHalfFaceIndex];
	      if (nextHalfFaceIndex < 0)
		{
		  ++numFaces;
		  Extract<_volumeType,_faceType>::GetFaceToNodes(cellToNodes,
								 localFaceIndex,
								 faceToNodes);
		  
		  //
		  // Assign the interior dofs to the current new face
		  //
		  FaceCompare<_faceType>::template OrientationPermutation<_degree>((char)1,
										   permloc);
		  
		  _I oldDofIndex = dofIndex;
		  
		  {
		    const _I at = cellsToDofsLd_ * cellIndex
		      + s_numVerticesInCell
		      + s_numEdgesInCell * s_numDofsPerInteriorEdge
		      + s_numDofsPerInteriorFace * localFaceIndex;
		    for (unsigned int i=0;i<s_numDofsPerInteriorFace;++i)
		      {
			cellsToDofs_[at+i] = dofIndex + 1 + permloc[i];
		      }
		    dofIndex += s_numDofsPerInteriorFace;
		  }
		  
		  _I lastDifferentHalfFaceIndex = initialHalfFaceIndex;
		  while (nextHalfFaceIndex < 0 && nextHalfFaceIndex != Hasher<_I>::s_default_hash)
		    {		    
		      _I testedCellIndex;
		      _I testedLocalFaceIndex;
		      HalfFaceDecomposition(-nextHalfFaceIndex - s_numVerticesInCell - s_numEdgesInCell * s_numDofsPerInteriorEdge,
					    s_numDofsPerCell,
					    s_numDofsPerInteriorFace,
					    &testedCellIndex,
					    &testedLocalFaceIndex);
		      
		      //
		      // We need to extract the next half face before we overwrite it.
		      //
		      const _I nextHalfFaceIndexBackup = nextHalfFaceIndex;
		      nextHalfFaceIndex = cellsToDofs_[-nextHalfFaceIndex];
		      
		      _I testedCellToNodes[s_numVerticesInCell];
		      GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
							  cellsToNodesLd_,					    
							  testedCellIndex,
							  testedCellToNodes);
		    
		      _I testedFaceToNodes[4];
		      Extract<_volumeType,FaceType::Triangle>::GetFaceToNodes(testedCellToNodes,
											     testedLocalFaceIndex,
									      testedFaceToNodes);
		      
		      if (FaceCompare<_faceType>::AreSame(faceToNodes,
							  testedFaceToNodes))
			{
			  FaceCompare<_faceType>::template OrientationPermutation<_degree>
			    (FaceCompare<_faceType>::Orientation(faceToNodes,
								 testedFaceToNodes),
			     permloc);

			  //
			  // We need to rebuild the linked list.
			  //
			  if (lastDifferentHalfFaceIndex != initialHalfFaceIndex)
			    {				
			      cellsToDofs_[-lastDifferentHalfFaceIndex] = nextHalfFaceIndex;
			    }
			
			  const _I at = cellsToDofsLd_*testedCellIndex+s_numVerticesInCell+ s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace*testedLocalFaceIndex;

			  // we copy 
			  for (unsigned int i=0;i<s_numDofsPerInteriorFace;++i)
			    {
			      cellsToDofs_[at + i] =  oldDofIndex + 1 + permloc[i];
			    }
			  
			  break;
			
			}
		      else
			{
			  //
			  // this is NOT the same face.
			  //
			  lastDifferentHalfFaceIndex = nextHalfFaceIndexBackup;
			}
		    
		    }		
		}
	    }
	}

#ifndef NDEBUG
      std::cout << "face table " << std::endl;
  
      //
      // mark face
      //
      for (_I cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  for (_I localFaceIndex=0;localFaceIndex<s_numFacesInCell;++localFaceIndex)
	    {
	      for (unsigned int k = 0;k<s_numDofsPerInteriorFace;++k)
		{
		  //
		  // only the first dof on edge.
		  //
		  std::cout << " " << cellsToDofs_[cellsToDofsLd_ * cellIndex+ s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace * localFaceIndex+k];
		}
	    }      
	  std::cout << std::endl;
	}

#endif
      std::cout << "numFaces " << numFaces << std::endl;
      std::cout << "dofIndex " << dofIndex << std::endl;
    }
  
  numDofs_[0] = dofIndex;
  return numFaces;  
};






template <unsigned int _degree,VolumeType::enum_t _volumeType, typename _I>
void GenerateEdgeHashBasedLinkedList(const _I numCells_,
				     const _I*__restrict__ cellsToNodes_,
				     const _I cellsToNodesLd_,
				     _I* __restrict__ cellsToDofs_,
				     const _I cellsToDofsLd_,
				     Hasher<_I>&hasher_)
{
  using Cell = ReferenceShapeVolume<_volumeType>;
  static constexpr unsigned int s_numVerticesInCell 	 = Cell::NbNodes;
  static constexpr unsigned int s_numEdgesInCell 	 = Cell::NbEdges;
  
  using fe_t = FiniteElement::Lagrange<_degree,DimensionType::Volume,_volumeType>;
#if 0
  static constexpr unsigned int s_numDofsPerCell 	 	= finiteElement_t::NumDofsPerCell;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= finiteElement_t::NumDofsPerInteriorEdge;
#endif

  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];


  
  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorEdge   " << s_numDofsPerInteriorEdge   << std::endl;
  if (s_numDofsPerInteriorEdge>0)
    {
      _I edgeToNodes[2];	  
      _I cellToNodes[s_numVerticesInCell];
      for (_I cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  //
	  // Copy connectivity.
	  //
	  GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					      cellsToNodesLd_,
					      cellIndex,
					      cellToNodes);
	    
	  _I at = cellsToDofsLd_*cellIndex + s_numVerticesInCell;
	  for (unsigned int localEdgeIndex=0;localEdgeIndex<s_numEdgesInCell;++localEdgeIndex)
	    {	      
	      //
	      // Extract the edgeToNodes.
	      //
	      GetEdgeToNodes<_volumeType>(cellToNodes,
					  localEdgeIndex,
					  edgeToNodes);
		
	      //
	      // Compute hash value.
	      //
	      const _I hashValue = EdgeCompare::HashCode(numCells_,
							 edgeToNodes);
		
	      //
	      // Assign the last half edge index with the same hash value.
	      //
	      cellsToDofs_[at] = hasher_[hashValue];
		
	      //
	      // Update the last half edge index with respect to the hash value.
	      //
	      hasher_[hashValue] = -at;
	      at += s_numDofsPerInteriorEdge;
	    }	
	}
    }
  
};



template <unsigned int _degree, VolumeType::enum_t _volumeType, typename _I>
unsigned long long int GenerateEdge(const _I numCells_,
				    const _I*__restrict__ cellsToNodes_,
				    const _I cellsToNodesLd_,
				    _I*numDofs_,
				    _I* __restrict__ cellsToDofs_,
				    const _I cellsToDofsLd_,
				    Hasher<_I>&hasher_)
{
  _I dofIndex = numDofs_[0];

  using Cell = ReferenceShapeVolume<_volumeType>;
  static constexpr unsigned int s_numVerticesInCell 	 = Cell::NbNodes;
  static constexpr unsigned int s_numEdgesInCell 	 = ReferenceShapeVolumeTetrahedron::NbEdges;
  
  using fe_t = FiniteElement::Lagrange<_degree,DimensionType::Volume,_volumeType>;


  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];

#if 0  
  static constexpr unsigned int s_numDofsPerCell 	 	= finiteElement_t::NumDofsPerCell;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= finiteElement_t::NumDofsPerInteriorEdge;
#endif
  
  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorEdge   " << s_numDofsPerInteriorEdge   << std::endl;
  unsigned long long int numEdges = 0;
  if (s_numDofsPerInteriorEdge>0)
    {
      
      static constexpr const _I default_hash = Hasher<_I>::s_default_hash;
      GenerateEdgeHashBasedLinkedList<_degree,_volumeType,_I>(numCells_,
							      cellsToNodes_,
							      cellsToNodesLd_,
							      cellsToDofs_,
							      cellsToDofsLd_,
							      hasher_);
      

      _I edgeToNodes[2];	  
      _I cellToNodes[s_numVerticesInCell];
      _I interiorEdgeDofIndices[s_numDofsPerInteriorEdge];    
      for (_I cellIndex=numCells_-1;cellIndex>=0;--cellIndex)
	{	
	  
	  GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
					      cellsToNodesLd_,
					      cellIndex,
					      cellToNodes);
	

	  for (int localEdgeIndex = s_numEdgesInCell-1;localEdgeIndex>=0;--localEdgeIndex)
	    { 
	      const _I initialHalfEdgeIndex = -(cellsToDofsLd_*cellIndex+s_numVerticesInCell + s_numDofsPerInteriorEdge*localEdgeIndex + 0);
	      _I nextHalfEdgeIndex = cellsToDofs_[-initialHalfEdgeIndex];
	      if (nextHalfEdgeIndex < 0)
		{
		  ++numEdges;
		  GetEdgeToNodes<_volumeType>(cellToNodes,
					      localEdgeIndex,
					      edgeToNodes);
		  
		  const bool edgeHasPositiveOrientation = EdgeCompare::HasPositiveOrientation(edgeToNodes);
		  //
		  // that's the first visit of the edge
		  //
		  if (edgeHasPositiveOrientation)
		    {
		      for (unsigned int i=0;i<s_numDofsPerInteriorEdge;++i)
			{
			  interiorEdgeDofIndices[i] = ++dofIndex;
			}		    
		    }
		  else
		    {
		      for (unsigned int i=0;i<s_numDofsPerInteriorEdge;++i)
			{
			  interiorEdgeDofIndices[s_numDofsPerInteriorEdge - 1 - i] = ++dofIndex;
			}
		    }
		
		  //
		  // Assign the interior dofs to the current new edge
		  //
		  {
		    const _I at = cellsToDofsLd_ * cellIndex + s_numVerticesInCell + s_numDofsPerInteriorEdge * localEdgeIndex;
		    for (unsigned int i=0;i<s_numDofsPerInteriorEdge;++i)
		      {
			cellsToDofs_[at+i] = interiorEdgeDofIndices[i];
		      }
		  }
		
		  _I lastDifferentHalfEdgeIndex = initialHalfEdgeIndex;
		  while (nextHalfEdgeIndex < 0 && nextHalfEdgeIndex != default_hash)
		    {		    
		      _I testedCellIndex;
		      _I testedLocalEdgeIndex;
		      HalfEdgeDecomposition(-nextHalfEdgeIndex - s_numVerticesInCell,
					    s_numDofsPerCell,
					    s_numDofsPerInteriorEdge,
					    &testedCellIndex,
					    &testedLocalEdgeIndex);
		    
		      //
		      // We need to extract the next half edge before we overwrite it.
		      //
		      const _I nextHalfEdgeIndexBackup = nextHalfEdgeIndex;
		      nextHalfEdgeIndex = cellsToDofs_[-nextHalfEdgeIndex];
		    
		      _I testedCellToNodes[s_numVerticesInCell];
		      GetCellToNodes<s_numVerticesInCell>(cellsToNodes_,
							  cellsToNodesLd_,
							  testedCellIndex,
							  testedCellToNodes);
		    
		      _I testedEdgeToNodes[2];
		      GetEdgeToNodes<_volumeType>(testedCellToNodes,
						  testedLocalEdgeIndex,
						  testedEdgeToNodes);
		    
		      if (EdgeCompare::AreSame(edgeToNodes,
					       testedEdgeToNodes))
			{
			  //
			  // We need to rebuild the linked list.
			  //
			  if (lastDifferentHalfEdgeIndex != initialHalfEdgeIndex)
			    {				
			      cellsToDofs_[-lastDifferentHalfEdgeIndex] = nextHalfEdgeIndex;
			    }
			
			  const _I at = s_numDofsPerCell*testedCellIndex+s_numVerticesInCell+s_numDofsPerInteriorEdge*testedLocalEdgeIndex;
			
			  if (EdgeCompare::HasPositiveOrientation(testedEdgeToNodes)
			      == edgeHasPositiveOrientation)
			    {
			      // copy 
			      for (unsigned int i=0;i<s_numDofsPerInteriorEdge;++i)
				{
				  cellsToDofs_[at + i] = interiorEdgeDofIndices[i];
				}
			    }
			  else
			    {
			      // copy reverse
			      for (unsigned int i=0;i<s_numDofsPerInteriorEdge;++i)
				{
				  cellsToDofs_[at + i] = interiorEdgeDofIndices[s_numDofsPerInteriorEdge - 1 - i];
				}
			    }
			}
		      else
			{
			  //
			  // this is NOT the same edge.
			  //
			  lastDifferentHalfEdgeIndex = nextHalfEdgeIndexBackup;
			}
		    }		
		}
	    }
	}
    
#ifndef NDEBUG
      std::cout << "edge table " << std::endl;
    
      //
      // mark edge
      //
      for (_I cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  for (unsigned int localEdgeIndex=0;localEdgeIndex<s_numEdgesInCell;++localEdgeIndex)
	    {
	      for (unsigned int k = 0;k<s_numDofsPerInteriorEdge;++k)
		{
		  //
		  // only the first dof on edge.
		  //
		  std::cout << " " << cellsToDofs_[cellsToDofsLd_ * cellIndex+ s_numVerticesInCell + s_numDofsPerInteriorEdge * localEdgeIndex+k];
		}
	    }      
	  std::cout << std::endl;
	}
    
#endif
      
    }

  numDofs_[0] = dofIndex;
  return numEdges;
};



//
//
// mixed shapes
//
// order of the shapes:
//
// tets, wedges, pyramids, hexahedrons
//
// Do edges,
//
// [-max -n0 -n1 ... -n2 ... -n3] [-max ... -n4 ... -n5  ... -n6  ... -n7]
//
// treat edges hexahedron
// assign dofs
// foreach edge in inplace linked lists
//
//     if (linked > lowerbound)
//     {
//        then it belongs to hexahedron
//        we continue to assign dofs
//     }
//    else
//     {
//        it points to the first edge with same hash code in another shape
//        we marked this edge as a shared edge
//        
//     }
//
// Do tets
//  Do triangles and leave the boundary ones, we will treat them after.
//
// Do wedges
//  Do triangles and leave the boundary ones, we will treat them after, they can be shared by other types.
//  Do quadrilaterals and leave the boundary ones, we will treat them after, they can be shared by other types.
//
// Do pyramids
//  Do triangles and leave the boundary ones, we will treat them after, they can be shared by other types.
//  Do quadrilaterals and leave the boundary ones, we will treat them after, they can be shared by other types.
//
// Do hexahedron
//  Do triangles and leave the boundary ones, we will treat them after.
//  Do quadrilaterals and leave the boundary ones, we will treat them after.
//
// Do remaining triangles
//
// Do remaining quadrilaterals
// 
//

template <unsigned int _degree,
	  VolumeType::enum_t _volumeType,
	  typename int_t>
int_t FiniteElementSpaceSize()
{
  //  using Cell = ReferenceShapeVolume<_volumeType>;
  
  //  static constexpr unsigned int s_numVerticesInCell = Cell::NbNodes;

  //
  // The finite element type.
  //
  using fe_t = FiniteElement::Lagrange<_degree, DimensionType::Volume, _volumeType>;
  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  
#if 0
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];
  static constexpr unsigned int s_numDofsPerInteriorFace 	= fe_t::NumDofsPerEntities[DimensionType::Face][FaceType::Triangle];
  static constexpr unsigned int s_numDofsPerInteriorVolume 	= fe_t::NumDofsPerEntities[DimensionType::Volume][VolumeType::Tetrahedron];

  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorEdge   " << s_numDofsPerInteriorEdge   << std::endl;
  std::cout << "s_numDofsPerInteriorFace   " << s_numDofsPerInteriorFace   << std::endl;
  std::cout << "s_numDofsPerInteriorVolume " << s_numDofsPerInteriorVolume << std::endl;
#endif
  return s_numDofsPerCell;
}

template <unsigned int _degree,
	  VolumeType::enum_t _volumeType,
	  typename int_t>
void  GenerateFiniteElementSpace(const int_t numCells_,
				 const int_t*__restrict__ cellsToNodes_,
				 const int_t cellsToNodesLd_,
				 int_t*numDofs_,
				 int_t*__restrict__ cellsToDofs_,
				 const int_t cellsToDofsLd_)
{
  //
  // The cell type.
  //
  using Cell = ReferenceShapeVolume<_volumeType>;
  
  static constexpr unsigned int s_numVerticesInCell = Cell::NbNodes;

  //
  // The finite element type.
  //
  using fe_t = FiniteElement::Lagrange<_degree, DimensionType::Volume, _volumeType>;

  static constexpr unsigned int s_numDofsPerCell 	 	= fe_t::NumDofs;
  static constexpr unsigned int s_numDofsPerInteriorEdge 	= fe_t::NumDofsPerEntities[DimensionType::Edge][EdgeType::Edge];
  static constexpr unsigned int s_numDofsPerInteriorFace 	= fe_t::NumDofsPerEntities[DimensionType::Face][FaceType::Triangle];
  static constexpr unsigned int s_numDofsPerInteriorVolume 	= fe_t::NumDofsPerEntities[DimensionType::Volume][VolumeType::Tetrahedron];

  std::cout << "s_numDofsPerCell           " << s_numDofsPerCell           << std::endl;
  std::cout << "s_numDofsPerInteriorEdge   " << s_numDofsPerInteriorEdge   << std::endl;
  std::cout << "s_numDofsPerInteriorFace   " << s_numDofsPerInteriorFace   << std::endl;
  std::cout << "s_numDofsPerInteriorVolume " << s_numDofsPerInteriorVolume << std::endl;


  
  //  int_t* cellsToDofs = new int_t[numCells_ * s_numDofsPerCell];
  
  //
  // Set dofs over the vertices
  //
  int_t dofIndex = numDofs_[0];
  for (int_t i=0;i<numCells_;++i)
    {
      for (unsigned int j=0;j<s_numVerticesInCell;++j)
	{
	  cellsToDofs_[cellsToDofsLd_*i+j] = cellsToNodes_[cellsToNodesLd_*i+j];
	  if (cellsToNodes_[cellsToNodesLd_*i+j] > dofIndex)
	    {
	      dofIndex = cellsToNodes_[cellsToNodesLd_*i+j];
	    }
	}  
    }

  
  unsigned long long int numEdges = 0;
  unsigned long long int numFaces = 0;
  
  if (s_numDofsPerInteriorEdge>0)
    {
      //
      // Set dofs over the edges.
      //
      Hasher<int_t> hasher(numCells_);      
      numEdges = GenerateEdge<_degree,_volumeType,int_t>(numCells_,
							 cellsToNodes_,
							 cellsToNodesLd_,
							 &dofIndex,
							 cellsToDofs_,
							 cellsToDofsLd_,
							 hasher);    
    }
  
  std::cout << "numEdges " << numEdges << std::endl;
  std::cout << "dofIndex " << dofIndex << std::endl;
  if (s_numDofsPerInteriorFace>0)
    {
      Hasher<int_t> hasher(numCells_);
      numFaces =  GenerateFace<_degree, _volumeType, FaceType::Triangle, int_t>(numCells_,
										cellsToNodes_,
										cellsToNodesLd_,
										&dofIndex,
										cellsToDofs_,
										cellsToDofsLd_,
										hasher);
    }
  
  std::cout << "numFaces " << numFaces << std::endl;  
  std::cout << "dofIndex " << dofIndex << std::endl;
  if (s_numDofsPerInteriorVolume>0)
    {
      GenerateVolume<_degree,int_t>(numCells_,
				    cellsToNodes_,
				    cellsToNodesLd_,
				    &dofIndex,
				    cellsToDofs_ + (s_numDofsPerCell - s_numDofsPerInteriorVolume),
				    cellsToDofsLd_);
    }
  
  
#if 0
  
  if (s_numDofsPerInteriorVolume>0)
    {
      //
      // Set dofs over the volumes.
      //
      for (int_t cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  const int_t at = s_numDofsPerCell * cellIndex + s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace * s_numFacesInCell;
	  for (unsigned int k = 0;k<s_numDofsPerInteriorVolume;++k)
	    {
	      cellsToDofs[at + k] = ++dofIndex;
	    }     
	}
    }
  
#ifndef NDEBUG
  std::cout << "volume table " << std::endl;    
  //
  // mark face
  //
  if (s_numDofsPerInteriorVolume>0)
    {
      for (int_t cellIndex=0;cellIndex<numCells_;++cellIndex)
	{
	  const int_t at = s_numDofsPerCell * cellIndex + s_numVerticesInCell + s_numEdgesInCell * s_numDofsPerInteriorEdge + s_numDofsPerInteriorFace * s_numFacesInCell;
	  for (unsigned int k = 0;k<s_numDofsPerInteriorVolume;++k)
	    {
	      //
	      // only the first dof on edge.
	      //
	      std::cout << " " << cellsToDofs[at +k];
	    }
	  std::cout << std::endl;
	}
    }
#endif
#endif  
  numDofs_[0] = ++dofIndex;
  //  return cellsToDofs;  
};


class MnsFiniteElementSpace3D : public Program
{
  
private: int_t m_degree;
public:
  
  MnsFiniteElementSpace3D(int 	 argc,
			  char * argv[]) : Program(argc, argv, true)
  {
    this->AddOption(new Option<int_t>(&m_degree,
				      "-k",
				      2,
				      true,
				      "Lagrange"));
  };

  template <typename _derivedClass>  void extract (const CRTP_MeshTopology<_derivedClass> &meshTopology_,int_t * cnc,int_t cncLd)
  {
    using this_t = CRTP_MeshTopology<_derivedClass>;
    using entitykind_t = typename this_t::entitykind_t;
    static constexpr DimensionType::enum_t meshDimension = this_t::Dimension;
    for( const auto cellType : entitykind_t::All)
      {
	const auto numCellsOfType = meshTopology_.template GetNumEntities<meshDimension>(cellType);
	if ( numCellsOfType > 0 )
	  {
	    typename this_t::template entity_t<DimensionType::Node> cellToNodes[8];
	    for (const auto cell : meshTopology_.template GetEntities<meshDimension>(cellType) )
	      {
		const auto numNodesInCell = meshTopology_.template GetEntityToEntities<meshDimension,DimensionType::Node>(cell,
															  cellToNodes);
		const auto cellIndex = meshTopology_.template GetEntityIndex<DimensionType::Volume>(cell);		
		for (unsigned int i=0;i<numNodesInCell;++i)
		  {
		    const auto nodeIndex = meshTopology_.template GetEntityIndex<DimensionType::Node>(cellToNodes[i]);
		    cnc[cellIndex * numNodesInCell + i] = nodeIndex;
		  }
	      }
	  }	
      }
  };

  
  virtual void Main()
  {
    
    std::cout << ReferenceShapeVolumeHexahedron::NumEntities[DimensionType::Node] << std::endl;
    if (this->HasVerbose())
      {
	LogMessage  << "degree "
		    << m_degree
		    << std::endl;
	
	LogMessage  << "ofilename "
		    << this->GetOfilename()
		    << std::endl;
      }

    
    if (Mpi::IsMaster())
      {
	
	{
	  AHF::Mesh3D mesh(this->GetInputFilename(0).c_str());	  
	  Output::Medit outputMedit("spaceAHF");
	  outputMedit << mesh;
	  
#if 1
	  const auto topology = mesh.GetTopology();
	  const auto numCells = topology->GetNumEntities<DimensionType::Volume>();
	  std::cout << "NUMENTITIES" << numCells << std::endl;

	  static constexpr int_t cncLd = 4;
	  int_t * cnc = new int_t[numCells * 4];
	  
	  extract(*topology,cnc,4);

	  
	  const int_t numDofsPerCell = FiniteElementSpaceSize<2,VolumeType::Tetrahedron,int_t>();	  
	  int_t * cncP = new int_t[numDofsPerCell * numCells];	  
	  std::cout << "FINITE ELEMENT SPACE #####" << std::endl;
	  int_t numDofs = 0;
	  GenerateFiniteElementSpace<2,VolumeType::Tetrahedron,int_t>(numCells,
								      cnc,
								      cncLd,
								      &numDofs,
								      cncP,
								      numDofsPerCell);
	  for (int i=0;i<4;++i)
	    {
	      for (int j=0;j<numDofsPerCell;++j)
		{
		  std::cout << " " << cncP[i*numDofsPerCell+j];
		}
	      std::cout << std::endl;
	    }
	  
	  std::cout << "FINITE ELEMENT SPACE #####" << std::endl;
#endif

	  


	  
//	  const int_t numCells_,
//									     const int_t*__restrict__ cellsToNodes_,
//									     int_t*numDofs_)
//	  
	  //
	  // Generate the finite element space
	  //
	  
	  Output::Vtk::Writer outputVtk("spaceVtk");
	  outputVtk << mesh;
	}
	
#if 0
	{	  
	  Input::Medit inputMedit(this->GetInputFilename(0).c_str());
	  
	  AHF::MeshTopology3D ahfMeshTopology3D(inputMedit);
	  
	  Output::Medit outputMedit("spaceAHFTopology");
	  outputMedit << ahfMeshTopology3D;
	  
	}
#endif
	
	Mesh<3,double,DimensionType::Volume> mesh(this->GetInputFilename(0).c_str());
	{
	  Output::Medit outputMedit("space");
	  outputMedit << *mesh.m_topology;//VolumeType::Tetrahedron;
	}
	
	{
	  MeshEntity<DimensionType::Volume> meshEntity(VolumeType::Hexahedron,4);
	  
	  std::cout << "encoding " << meshEntity.m_encoding << std::endl;
	  std::cout << "type " << meshEntity.GetType() << std::endl;
	  std::cout << "index " << meshEntity.GetIndex() << std::endl;
	}
	
	{
	  MeshEntity<DimensionType::Face> meshEntity(FaceType::Quadrilateral, 4);
	  
	  std::cout << "encoding " << meshEntity.m_encoding << std::endl;
	  std::cout << "type " << meshEntity.GetType() << std::endl;
	  std::cout << "index " << meshEntity.GetIndex() << std::endl;
	}

	{
	  MeshEntity<DimensionType::Face> meshEntity(FaceType::Quadrilateral, 5);
	  
	  std::cout << "encoding " << meshEntity.m_encoding << std::endl;
	  std::cout << "type " << meshEntity.GetType() << std::endl;
	  std::cout << "index " << meshEntity.GetIndex() << std::endl;
	}

	
#if 0
	static constexpr unsigned int _degree = 29;
	int_t numDofs;
	int_t* cellsToDofs = GenerateFiniteElementSpace<_degree,VolumeType::Hexahedron,int_t>(10,
											       NULL,
											       &numDofs);

#endif	
#if 0
	
	// const unsigned int numIfilenames = this->GetNumInputFiles();
	pMedit medit = Medit_new(this->GetInputFilename(0).c_str());

	eVolume convert[] = {__eVolume_TETRAHEDRON,
			     __eVolume_PYRAMID,
			     __eVolume_WEDGE,
			     __eVolume_HEXAHEDRON};
	
	
	I numCells[4]{0};
	for(const auto volumeKind : VolumeType::AllValues)
	  {
	    numCells[volumeKind] = Medit_get_nbVolumes	(medit,
							 convert[volumeKind]);
	    std::cout << "# "  << volumeKind << " " << numCells[volumeKind] << std::endl;
	  }
	I totalNumCells = numCells[0] + numCells[1] + numCells[2] + numCells[3];
	I numDifferentCells = (numCells[0] == 0) ? 0 : 1;
	numDifferentCells += (numCells[1] == 0) ? 0 : 1;
	numDifferentCells += (numCells[2] == 0) ? 0 : 1;
	numDifferentCells += (numCells[3] == 0) ? 0 : 1;
	pI begin = new I[4+1];
	begin[0] = 0;
	
	const I nn[]= {4,5,6,8};
	{
	  unsigned int i=1;
	  for(const auto volumeKind : VolumeType::AllValues)
	    {
	      begin[i] = begin[i-1] + numCells[volumeKind] * nn[volumeKind];
	      ++i;
	    }
	}
	
	
 	pI tetcod = new I[totalNumCells];
	pI cellsToNodes = new I[4*numCells[0] + 5*numCells[1] + 6*numCells[2] + 8*numCells[3]];
	for(const auto volumeKind : VolumeType::AllValues)
	  {
	    if (numCells[volumeKind]>0)
	      {		
		Medit_get_cncVolume(medit,
				    &cellsToNodes[begin[volumeKind]],
				    nn[volumeKind],
				    //
				    //
				    // Come and correct tetcod, 
				    //
				    //
				    tetcod,
				    1,
				    convert[volumeKind]);
	      }
	    
	  }
#if 0
 	pI tetcod = new I[numTetrahedrons];
	pI cellsToNodes = new I[4*numTetrahedrons];
	
	
	
	I numTetrahedrons = Medit_get_nbVolumes	(medit,
						 __eVolume_TETRAHEDRON);
#endif
	I numVertices = Medit_get_nbVertices	(medit);
	
	std::cout << "1##############################" << std::endl;
	pPoints xyz = Points_new(__eDim_3,
				 numVertices);
	
	pI cod = new I[numVertices];
	I n1 = 1;
	Medit_get_Points(medit,
			 xyz,
			 cod,
			 &n1);

	I numTetrahedrons = numCells[0];
#if 0
	std::cout << "1##############################" << std::endl;
 	pI tetcod = new I[numTetrahedrons];
	pI cellsToNodes = new I[4*numTetrahedrons];
	
	Medit_get_cncVolume(medit,
			    cellsToNodes,
			    4,
			    tetcod,
			    1,
			    __eVolume_TETRAHEDRON);
	
#endif
#if 0	
	std::cout << "numtet " << numTetrahedrons << std::endl;
	for (I i=0;i<numTetrahedrons;++i)
	  {
	    std::cout << " " << cellsToNodes[4*i+0]
		      << " " << cellsToNodes[4*i+1]
		      << " " << cellsToNodes[4*i+2]
		      << " " << cellsToNodes[4*i+3]
		      << std::endl;
	  }
#endif
	
	static constexpr unsigned int _degree = 7;
	I numDofs;
	pI cellsToDofs = GenerateFiniteElementSpace<_degree,VolumeType::Tetrahedron,I>(numTetrahedrons,
										       cellsToNodes,
										       &numDofs);
	
	





	
	std::cout << "NumDofs " << numDofs << std::endl;
	double*coo = new double[numDofs * 3];
	pTreilliVolume treilli = TreilliVolume_new(__eVolume_TETRAHEDRON,
						   _degree);
	I nbv = TreilliVolume_get_nbVertices(treilli);
	
	double*rst = new double[nbv*3];
	TreilliVolume_get_coo_double(treilli,
				     rst,
				     nbv);
	double x0[3];
	double x1[3];
	double x2[3];
	double x3[3];
	bool *flag=new bool[numDofs];
	for (I i=0;i<numDofs;++i)
	  {
	    flag[i]=false;
	  }
	for (I i = 0 ;i<numTetrahedrons;++i)
	  {
	    Points_get		(xyz,
				 cellsToNodes[4*i+0],
				 x0);
	    Points_get		(xyz,
				 cellsToNodes[4*i+1],
				 x1);
	    Points_get		(xyz,
				 cellsToNodes[4*i+2],
				 x2);
	    Points_get		(xyz,
				 cellsToNodes[4*i+3],
				 x3);

	    for (I j=0;j<nbv;++j)
	      {
		I k = cellsToDofs[nbv*i+j];
		
		const double
		  r = rst[j],
		  s = rst[nbv+j],
		  t = rst[2*nbv+j];

		const double
		  l0 = 1.0 -r -s-t,
		  l1 = r,
		  l2= s,
		  l3 = t;

		const double
		  x = l0 * x0[0] + l1*x1[0] + l2*x2[0] + l3*x3[0],
		  y = l0 * x0[1] + l1*x1[1] + l2*x2[1] + l3*x3[1],
		  z = l0 * x0[2] + l1*x1[2] + l2*x2[2] + l3*x3[2];
		
		if (k>=numDofs)
		  {
		    std::cerr << "ddd" << std::endl;
		    exit(1);
		  }
		flag[k]=true;
		coo[3*k+0] = x;
		coo[3*k+1] = y;
		coo[3*k+2] = z;
	      }
	  }

	bool invalid = false;
	for (I i=0;i<numDofs;++i)
	  {
	    if (flag[i]==false)
	      {
		invalid = true;
		std::cout << "invalid " << i << std::endl;
	      }
	  }

	if (invalid)
	  {
	    exit(1);
	  }
	FILE * out = fopen("out.mesh","w");
	fprintf(out,"MeshVersionFormatted\n1\nDimension\n3\nVertices\n" ifmt "\n",numDofs);
#if 1
	for (I i =0;i<numDofs;++i)
	  {
	    fprintf(out,"%e %e %e 0\n",coo[3*i+0],coo[3*i+1],coo[3*i+2]);
	  }
#endif	
	I nbSubVolumes = TreilliVolume_get_nbSubvolumes	(treilli);
	fprintf(out,"Tetrahedra\n" ifmt "\n",numTetrahedrons * nbSubVolumes);
	I* subcnc=new I [4*nbSubVolumes];
	TreilliVolume_get_cnc		(treilli,
					 subcnc,
					 4);
	//	printf("allo "ifmt"\n",nbv);
	//	exit(1);
	for (I i = 0 ;i<numTetrahedrons;++i)
	  {	    
	    for (I j = 0 ;j<nbSubVolumes;++j)
	      {
		for (I k= 0;k<4;++k)
		  {
		    //	    std::cout << "yo " << 4*j+k<<std::endl;
		    //		    std::cout << " " << subcnc[4*j+k];
		    fprintf(out," " ifmt "",cellsToDofs[nbv*i+subcnc[4*j+k]]+1);
		  }
		fprintf(out," 0\n");
		//	std::cout << std::endl;
	      }
	    //	    exit(1);
	  }

	fprintf(out,"End");
	fclose(out);
#endif
      }

  };
};


#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <assert.h>


int main(int 	argc_, 
	 char* argv_[])
{
  MnsFiniteElementSpace3D application(argc_,argv_);
  application.Run();
  return 0;
}


#if 0

  
  std::cout << ReferenceCell::Tetrahedron::GetNumEntities<DimensionType::Node>() << std::endl;
  std::cout << ReferenceCell::Tetrahedron::GetNumEntities<DimensionType::Edge>() << std::endl;
  std::cout << ReferenceCell::Tetrahedron::GetNumEntities<DimensionType::Face>() << std::endl;
  
  for(const auto& edgeToNodes : ReferenceCell::Tetrahedron::EdgesToNodes)
    {
      for (const auto localNodeIndex : edgeToNodes)
	{	  
	  std::cout << " " << localNodeIndex;	  
	}
      std::cout << std::endl;
    }
  
  std::cout << ReferenceCell::Wedge::GetNumEntities<DimensionType::Node>() << std::endl;
  std::cout << ReferenceCell::Wedge::GetNumEntities<DimensionType::Edge>() << std::endl;
  std::cout << ReferenceCell::Wedge::GetNumEntities<DimensionType::Face>() << std::endl;

#endif






